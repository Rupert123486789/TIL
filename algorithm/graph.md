## ![펭귄](array_1.assets/펭귄.png)

<br>

* **학습 목표**
  * 실 세계 문제를 그래프로 추상화해서 해결하는 방법을 학습함
    * 그래프 탐색 기법인 BFS와 DFS에 대해 학습함
    * 그래프 알고리즘에 활용되는 상호배타 집합(Disjoint-Sets)의 자료구조에 대해 학습함
    * 최소 신장 트리(Minimum Spanning Tree)를 이해하고 탐욕 기법을 이용해서 그래프에서 최소 신장 트리를 찾는 알고리즘을 학습함
    * 그래프의 두 정점 사이의 최단 경로(Shortest Path)를 찾는 방법을 학습함

<br>

# 그래프 & 백트래킹(Graph & Backtracking)

<br>

### 1. 그래프 기본

<br>

* **문제 제시 : 친구 관계**
  * A의 친구는 B
  * C의 친구는 E, F
  * (D - E), (F - G), (N - B, I, L), (G - A, C, D, H), (I - J, H), (B - D, K, L), (M - I, J), (E - A, H), (C - B, I , L), (B - I), (J - A, G)
  * A의 친구 중에 친구가 가장 많은 친구는 누구인가?

<br>

* 2차원 배열에서 순열 만들기
  * 칸에 좌표를 집어넣고 i, j, k로 꺼내기
  * 고유번호 붙이기(i * N + j)	

<br>

* **그래프**
  * 그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현함
  * 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구서오딘 자료 구조
    * `|V|` : 정점의 개수, `|E|` : 그래프에 포함된 간선의 개수
    * ✨`|V|` 개의 정점을 가지는 그래프는 최대 `|V|`(`|V|` - 1) / 2 간선이 가능 (Tree는 V = E +1)
      * ex 5개 정점이 있는 그래프의 최대 간선 수는 10(=5*4/2)개 임.
  * 선형 자료구조나 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기에 용이함

<br>

* **그래프 유형**
  * 무향 그래프(Undirected Graph)
  * 유향 그래프(Directed Graph)
  * 가중치 그래프(Weighted Graph)
  * 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)
  * ![image-20220409153404123](graph.assets/image-20220409153404123.png)
    * 어떤 정점에서 출발해서 간선을 따라 이동했는데 자기 자신으로 돌아오는 경우 : 사이클
  * 완전 그래프
    * 정점들에 대해 가능한 모든 간선들을 가진 그래프
      * ![image-20220409153542447](graph.assets/image-20220409153542447.png)
  * 부분 그래프 
    * 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

<br>

* **인접 정점**
  * 인접(Adjacency)
    * 두 개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 함
    * 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있음
    * ![image-20220409153641858](graph.assets/image-20220409153641858.png)

<br>

* **그래프 경로**
  * 경로란 간선들을 순서대로 나열한 것
    * 간선들 : (0, 2), (2, 4), (4, 6)
    * 정점들 : 0 - 2 - 4 - 6
  * 경로 중 한 정점을 최대한 한번만 지나는 경로를 **✨단순경로**라 함
    * 0 - 2 - 4 - 6, 0 - 1 - 6
  * 시작한 정점에서 끝나는 경로를 **✨사이클(Cycle)**이라고 함
    * 1 - 3 - 5 - 1
    * ![image-20220409153828055](graph.assets/image-20220409153828055.png)
  * DAG : 자기 자신으로 돌아오는 경로가 없는 그래프



<br>

* **그래프 표현**
  * 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
  * 인접 행렬 (Adjacent matrix)
    * `|V|`x `|V|` 크기의 2차원 배열을 이용해서 간선 정보를 저장
    * 배열의 배열(포인터 배열)
  * 인접 리스트 (Adjacent List)
    * 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
  * 간선의 배열
    * 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

<br>

* **인접 행렬**
  * 두 정점을 연결하는 간선의 유무를 행렬로 표현
    * `|V|`x `|V|`  정방 행렬
    * 행 번호와 열 번호는 그래프의 정점에 대응
    * 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
    * 무향 그래프
      * i번째 행의 합 = i번째 열의 합 = V~i~의 차수
    * 유향 그래프
      * 행 i의 합 = V~i~의 진출 차수
      * 열 i의 합 = V~i~의 진입 차수
  * ![image-20220409154335847](graph.assets/image-20220409154335847.png)
    * 행 -> 열로 방향 표시
    * 진출 차수 : 나가는게 몇 개지?
    * 진입 차수 : 들어오는게 몇 개지?
    * 알고리즘 문제를 풀때 방향성은 💥**저장 될 때만 신경** 쓰면 됨 / 저장만 잘하면 안 틀림
    * ex. 친구 관계(방향성 X), 비상 연락망(방향성 O)
  * 인접 행렬의 단점은?
    * ![image-20220409154633324](graph.assets/image-20220409154633324.png)
    * 용도에 따른 저장 방법 설정
    * ✨100만 이상이면 인접리스트, 인접행렬은 힘듬

<br>

* **인접 리스트**
  * 각 정점에 대한 인접 정점들을 순차적으로 표현
  * 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
    * ![image-20220409154738834](graph.assets/image-20220409154738834.png)
    * ![image-20220409154852873](graph.assets/image-20220409154852873.png)

<br>

---

<br>

### 2. 그래프 탐색

<br><br><br><br><br><br>

---

<br>

### 3. 서로소 집합들

<br><br><br><br><br>

---

<br>

### 4. 최소 비용 신장 트리(MST)

<br><br><br><br><br><br>

----

<br>

### 5. 최단 경로

<br><br><br><br><br><br>
