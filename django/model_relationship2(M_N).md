## ![펭귄](template_view_routing.assets/펭귄.png)

<br>

## Model Relationship II

<br>

## Intro

<br>

### 1. 병원 진료 기록 시스템

<br>

* **병원 진료 기록 시스템을 통한 M:N 관계 학습**
  * 환자와 의사가 사용하는 병원 진료 기록 시스템 구축
    * 병원 시스템에서 가장 핵심이 되는 객체는 무엇일까? => 환자와 의사
    * 이 둘의 관계를 어떻게 표현할 수 있을까?
* **시작하기 전**
  * 모델링은 현실 세계를 최대한 유사하게 반영하기 위한 것
  * 우리 일상에 가까운 예시를 통해 DB를 모델링하고, 그 내부에서 일어나는 데이터의 흐름을 어떻게 제어할 수 있을지 고민해보기

<br>

* **1. 1:N의 한계**

  * 1:N 모델 관계 설정

  * 의사 2명과 환자 2명 생성

  * 1번 환자가 1번 의사의 진료를 마치고, 2번 의사에게도 방문하려고 한다면, 새로운 예약을 생성해야 함.

  * 기존의 예약을 유지한 상태로 새로운 예약을 생성

  * 새로 생성한 3번 환자는 1번 환자와 다름

  * 한 번에 두 의사에게 진료를 받고자 함

  * 하나의 외래 키에 2개의 의사 데이터를 넣을 수 없음

  * 정리

    * 새로운 예약을 생성하는 것이 불가능
      * 새로운 객체를 생성해야 함
    * 여러 의사에게 진료 받은 기록을 환자 한 명에 저장할 수 없음
      * 외래 키에 '1, 2' 형식의 데이터를 사용 할 수 없음

    

<br>

* **2. 중개 모델**
  * 중개 모델(혹은 중개 테이블, Associative Table) 작성
  * 중개 모델과의 모델 관계 확인
    * ![image-20220423203618870](model_relationship2(M_N).assets/image-20220423203618870.png)
  * 의사 1명과 환자 1명 생성 및 예약 생성
  * 예약 내역 조회
  * 의사의 예약 환자 조회
  * 환자의 담당 의사 조회
  * 환자 1명 추가 생성 및 1번 의사에게 예약 생성
  * 의사의 예약 환자 조회
  * ✨중개 모델에 의해 다대다 관계가 설정되었음

<br>

* **3. ManyToManyField**
  * 다대다 (M:N, many-to-many) 관계 설정 시 사용하는 모델 필드
  * 하나의 필수 위치인자(M:N 관계로 설정할 모델 클래스)가 필요
  * ManyToManyField 작성 (중개 모델 삭제)
    * 필드 작성 위치는 Doctor 또는 Patient 모두 작성 가능(✨어디든 상관 없음)
    * 💥1:N과 의 차이점 
      * M:N 관계를 맺는 2개의 테이블에는 아무런 변화가 없음(외래키 X)
      * 2개의 테이블이 같이 사용하는 중개 테이블이 생성됨
      * 1:N에서는 외래키가 무조건 N쪽에 위치(종속관계)
      * M:N은 어느 곳에도 서로 종속되지 않음(대등한 관계)
    * 단지 참조 / 역참조의 관계만 바뀜
      * 중개 모델 일경우는 둘다 역참조임
      * ManyToManyField에서는 필드를 중심으로 참조/역참조
  * ManyToManyField로 인해 생성된 중개 테이블 확인
  * 의사 1명과 환자 2명 생성
  * 예약 생성 (참조)
    1. patient1이 doctor1에게 예약
    2. patient1이 예약한 의사 목록 확인
    3. doctor1에게 예약된 환자 목록 확인
  * 예약 생성 (역참조)
    1. doctor1이 patient2를 예약
    2. doctor1에게 예약된 환자 목록 확인
    3. patient2, patien1이 각각 예약한 의사 목록 확인
    4. add라는 queryser API가 생김
    5. ✨역참조로 진행했을뿐, 환자가 참조했을때의 데이터 결과와 동일함
  * 중개 테이블 데이터 확인
  * 예약 삭제 (역참조)
    1. doctor1이 patient1 진료 예약 취소
    2. doctor1에게 예약된 환자 목록 확인
    3. patient1이 예약한 의사 목록 확인
  * 예약 삭제 (참조)
    1. patient2가 doctor1 진료 예약 취소
    2. patient2가 예약한 의사 목록 확인
    3. doctor1에게 예약된 환자 목록 확인
  * 중계 테이블 데이터 확인

<br>

* **4. related_name**
  * target model(관계 필드를 가지지 않은 모델-의사)이 source model(관계 필드를 가진 모델-환자)을 참조할 때(역참조) 사용할 manager의 이름을 설정
  * ✨역참조 : 타겟 모델이 소스모델을 참조한다
  * 즉, 역참조 시에 사용하는 manager의 이름을 설정
  * ForeignKey의 related_name과 동일
    * ![image-20220423204956792](model_relationship2(M_N).assets/image-20220423204956792.png)
    * patient_ser => patients (복수형, M:N임을 나타내기 위해)
  * doctor1의 예약 호나자 목록 확인 해보기 (역참조)
  * ✨related_name 설정 후 기존의 _set manager는 더 이상 사용할 수 없음

<br>

* **중개 모델(테이블) in Django**
  * django는 ManyToManyField를 통해 중개 테이블을 자동으로 생성
  * 그렇다면 중개 테이블을 직접 작성하는 경우는 없을까?
    * 중개 테이블을 수동으로 지정하려는 경우 through 옵션을 사용하여, 중개 테이블을 나타내는 Django 모델을 지정할 수 있음 (다음 챕터에서 확인)
    * ✨가장 일반적인 용도는 중개 테이블에 추가 데이터를 사용해 다대다 관계로 연결하려는 경우에 사용
      * ex. 예약시간 / 병명 등 추가 데이터를 넣을 수가 없음 (ManyToManyField 만으로는)
      * 직접 작성해야함

<br>

* **요약**
  * 실제 Doctor와 Patient 테이블이 변하는 것은 없음
  * 1:N 관계는 완전한 종속의 관계이지만, M:N 관계는 **💥의사에게 진찰받는 환자, 환자를 진찰하는 의사의 두가지 형태로 모두 표현이 가능한 것**

<br>

----

<br>

## ManyToManyField

<br>

### 1. 좋아요 기능 (Like)

<br><br><br><br><br>

---

<br>

### 2. Profile Page

<br><br><br><br><br>

---

<br>

### 3. 팔로우 기능 (Follow)

<br><br><br><br><br><br><br>

